<% layout("/layouts/boilerplate") %>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
        }

        #map {
            height: 500px;
            width: 1000px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin: 10px 10px;
            display: block;
        }

        .mapBody {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
        }

        input[type="text"],
        button {
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
            width: calc(100% - 40px);
            max-width: 300px;
            box-sizing: border-box;
        }

        input[type="text"] {
            display: inline-block;
            background-color: #fff;
        }

        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: none;
        }

        button:hover {
            background-color: #0056b3;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        #warning {
            font-size: 14px;
            color: #ff0000;
            margin: 10px auto;
            text-align: center;
        }

        @media screen and (max-width: 1024px) {
            #map {
                width: 90%;
            }

            input[type="text"],
            button {
                width: calc(100% - 20px);
                max-width: none;
            }
        }
    </style>
    <script
        src="https://maps.googleapis.com/maps/api/js?key=process.env.YOUR_API_KEY&libraries=visualization,drawing,places&callback=initMap"
        async defer></script>
    </head>

    <body>
        <div class="mapBody">
            <div id="map"></div>
        </div>

        <div class="controls">
            <input type="text" id="source-input" placeholder="Fetching live location..." />
            <input type="text" id="destination-input" placeholder="Enter destination" />
            <button id="get-route">Get Route</button>
        </div>

        <div id="warning"></div>

        <script>
            var complaints = <% - complaints %>;  // Your complaints data
            var map;
            var heatmap;
            var markers = [];
            var bounds;
            var directionsService;
            var directionsRenderer;
            var heatmapData = [];  // Store heatmap data for region checks
            var liveLocationCoords = null;

            function initMap() {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 19.0760, lng: 72.8777 },
                    zoom: 13
                });

                bounds = new google.maps.LatLngBounds();
                console.log(bounds)

                // Prepare heatmap data
                var activeInfoWindow = null;  // To track the currently open InfoWindow

                complaints.forEach(complaint => {
                    geocodeLocation(complaint.location)
                        .then(coords => {
                            if (coords) {
                                var latLng = new google.maps.LatLng(coords.lat, coords.lng);
                                var marker = new google.maps.Marker({
                                    position: latLng,
                                    map: map,
                                    title: complaint.complain
                                });

                                var infoWindow = new google.maps.InfoWindow({
                                    content: "Complaint: " + complaint.complain + "<br>Location: " + complaint.location
                                });

                                // Add mouseover event to open the InfoWindow
                                marker.addListener('mouseover', function (event) {
                                    if (activeInfoWindow) {
                                        activeInfoWindow.close();  // Close any previously opened InfoWindow
                                    }
                                    infoWindow.setPosition(event.latLng);
                                    infoWindow.open(map, marker);
                                    activeInfoWindow = infoWindow;  // Track the currently open InfoWindow
                                });

                                // Add mouseout event to close the InfoWindow with a small delay
                                marker.addListener('mouseout', function () {
                                    setTimeout(function () {
                                        if (activeInfoWindow === infoWindow) {  // Only close if this is the active InfoWindow
                                            infoWindow.close();
                                            activeInfoWindow = null;  // Clear the reference to the active InfoWindow
                                        }
                                    }, 200);  // Delay to prevent blinking
                                });
                            } else {
                                console.warn(`Skipping location: ${complaint.location} (geocoding failed)`);
                            }
                            if (heatmapData.length === complaints.length) {
                                createHeatmap(heatmapData);
                                map.fitBounds(bounds);
                            }
                        });
                });


                directionsService = new google.maps.DirectionsService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    map: map,
                    suppressMarkers: true // Don't show default markers
                });

                // Get live location
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(position => {
                        liveLocationCoords = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        map.setCenter(liveLocationCoords);

                        // Add a marker for the live location
                        new google.maps.Marker({
                            position: liveLocationCoords,
                            map: map,
                            color: 'yellow',
                            title: "Your Live Location"
                        });

                        reverseGeocodeLocation(liveLocationCoords)
                            .then(address => {
                                document.getElementById('source-input').value = address;  // Display address in source input
                            });

                        // Set up the route when the button is clicked
                        document.getElementById('get-route').addEventListener('click', () => {
                            const source = document.getElementById('source-input').value;
                            const destination = document.getElementById('destination-input').value;
                            calculateRoute(source, destination);
                        });
                    }, () => {
                        handleLocationError(true, map.getCenter());
                    });
                } else {
                    handleLocationError(false, map.getCenter());
                }
            }

            function createHeatmap(data) {
                heatmap = new google.maps.visualization.HeatmapLayer({
                    data: data,
                    map: map
                });

                // Keep the radius size constant
                heatmap.set('radius', 50);
                heatmap.set('opacity', 0.7);
                heatmap.set('dissipating', true);
                heatmap.set('maxIntensity', 10);

                // Update gradient to reflect severity levels, colors will indicate intensity
                heatmap.set('gradient', [
                    'rgba(0, 255, 0, 0)',
                    'rgba(0, 255, 0, 1)',
                    'rgba(255, 255, 0, 1)',
                    'rgba(255, 165, 0, 1)',
                    'rgba(255, 0, 0, 1)'
                ]);
            }

            function calculateRoute(start, end) {
                directionsService.route(
                    {
                        origin: start,
                        destination: end,
                        travelMode: google.maps.TravelMode.DRIVING
                    },
                    (response, status) => {
                        if (status === 'OK') {
                            directionsRenderer.setDirections(response);
                            const severity = checkRouteAgainstHeatmap(response.routes[0].legs[0].steps);

                            // Extract route details for backend
                            const routeDetails = {
                                start: start,
                                end: end,
                                steps: response.routes[0].legs[0].steps.map(step => ({
                                    start_location: step.start_location.toString(),
                                    end_location: step.end_location.toString(),
                                    distance: step.distance.text,
                                    duration: step.duration.text,
                                })),
                                overallSeverity: severity // Include overall severity here
                            };

                            // Send route details to the backend
                            fetch('/api/rate-route', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(routeDetails)
                            })
                                .then(response => response.json())
                                .then(data => {
                                    // Handle response from backend (e.g., display rating)
                                    if (data.rating) {
                                        document.getElementById('warning').innerHTML += `<br>Route Safety Rating: ${data.rating} `;
                                    }
                                })
                                .catch(error => {
                                    console.error('Error sending route details to backend:', error);
                                });
                        } else {
                            window.alert('Directions request failed due to ' + status);
                        }
                    }
                );
            }



            function checkRouteAgainstHeatmap(steps) {
                let overallSeverity = 'Low'; // Default severity
                const severityLevels = { 'Critical': 3, 'Mild': 2, 'Low': 1 };
                const proximityThreshold = 0.5;
                let warningMessage = '';
                let warningDisplayed = false; // Flag to track if a warning has already been displayed

                steps.forEach(step => {
                    const stepPath = step.path;
                    stepPath.forEach(latLng => {
                        heatmapData.forEach(heatmapPoint => {
                            const distance = calculateDistance(latLng, heatmapPoint.location);
                            if (distance <= proximityThreshold) {
                                const currentSeverity = getSeverityFromWeight(heatmapPoint.weight);
                                if (heatmapPoint.weight > 1) {
                                    // Reverse geocode to get the address for latLng
                                    reverseGeocodeLocation(latLng).then(address => {
                                        if (!warningDisplayed) { // Only display warning once
                                            warningMessage += `Warning: This route passes through a high-risk area near ${address} with complaints. Consider avoiding this area!<br>`;
                                            document.getElementById('warning').innerHTML = warningMessage || 'Route is clear.';
                                            warningDisplayed = true; // Set the flag to true to prevent duplicate warnings
                                        }
                                    });
                                }
                                if (severityLevels[currentSeverity] > severityLevels[overallSeverity]) {
                                    overallSeverity = currentSeverity; // Update overall severity
                                }
                            }
                        });
                    });
                });

                return overallSeverity; // Return the calculated overall severity
            }


            function getSeverityFromWeight(weight) {
                switch (weight) {
                    case 3:
                        return 'Critical';
                    case 2:
                        return 'Mild';
                    case 1:
                    default:
                        return 'Low';
                }
            }



            function calculateDistance(latLng1, latLng2) {
                const R = 6371;
                const dLat = degreesToRadians(latLng2.lat() - latLng1.lat());
                const dLng = degreesToRadians(latLng2.lng() - latLng1.lng());
                const a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(degreesToRadians(latLng1.lat())) * Math.cos(degreesToRadians(latLng2.lat())) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            function degreesToRadians(degrees) {
                return degrees * (Math.PI / 180);
            }

            function geocodeLocation(location) {
                return new Promise((resolve, reject) => {
                    var geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ address: location }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            var coords = {
                                lat: results[0].geometry.location.lat(),
                                lng: results[0].geometry.location.lng()
                            };
                            resolve(coords);
                        } else {
                            console.error(`Geocoding error for location "${location}": ${status}`);
                            resolve(null);
                        }
                    });
                });
            }

            function reverseGeocodeLocation(latLng) {
                return new Promise((resolve, reject) => {
                    var geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: latLng }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            resolve(results[0].formatted_address);
                        } else {
                            console.error('Geocoding failed: ' + status);
                            resolve('Unknown location');
                        }
                    });
                });
            }

            function getWeightFromSeverity(severity) {
                switch (severity) {
                    case 'Critical':
                        return 3;
                    case 'Mild':
                        return 2;
                    case 'Low':
                        return 1;
                    default:
                        return 1;
                }
            }

            function handleLocationError(browserHasGeolocation, pos) {
                alert(browserHasGeolocation ?
                    'Error: The Geolocation service failed.' :
                    'Error: Your browser doesn\'t support geolocation.');
                map.setCenter(pos);
            }

            window.onload = initMap;

            function initMap() {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 19.0760, lng: 72.8777 },
                    zoom: 13
                });

                bounds = new google.maps.LatLngBounds();

                directionsService = new google.maps.DirectionsService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    map: map,
                    suppressMarkers: true // Don't show default markers
                });

                // Populate heatmap data and markers
                populateHeatmapData().then(() => {
                    createHeatmap(heatmapData);
                    map.fitBounds(bounds);
                });

                // Get live location
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(position => {
                        liveLocationCoords = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        map.setCenter(liveLocationCoords);

                        // Add a marker for the live location
                        new google.maps.Marker({
                            position: liveLocationCoords,
                            map: map,
                            title: "Your Live Location"
                        });

                        reverseGeocodeLocation(liveLocationCoords)
                            .then(address => {
                                document.getElementById('source-input').value = address;  // Display address in source input
                            });

                        // Set up the route when the button is clicked
                        document.getElementById('get-route').addEventListener('click', () => {
                            const source = document.getElementById('source-input').value;
                            const destination = document.getElementById('destination-input').value;
                            calculateRoute(source, destination);
                        });
                    }, () => {
                        handleLocationError(true, map.getCenter());
                    });
                } else {
                    handleLocationError(false, map.getCenter());
                }
            }

            function populateHeatmapData() {
                var geocodingPromises = complaints.map(complaint => {
                    return geocodeLocation(complaint.location).then(coords => {
                        if (coords) {
                            // Add marker for each complaint
                            var latLng = new google.maps.LatLng(coords.lat, coords.lng);
                            var marker = new google.maps.Marker({
                                position: latLng,
                                map: map,
                                title: complaint.complain
                            });

                            bounds.extend(latLng);

                            // Create InfoWindow for marker
                            var infoWindow = new google.maps.InfoWindow({
                                content: "Complaint: " + complaint.complain + "<br>Location: " + complaint.location
                            });

                            marker.addListener('mouseover', function (event) {
                                infoWindow.setPosition(event.latLng);
                                infoWindow.open(map, marker);
                            });

                            marker.addListener('mouseout', function () {
                                infoWindow.close();
                            });

                            // Add this point to heatmapData
                            heatmapData.push({
                                location: latLng,
                                weight: getWeightFromSeverity(complaint.severity)
                            });
                        }
                    });
                });

                // Wait for all geocoding promises to complete
                return Promise.all(geocodingPromises);
            }

            function createHeatmap(data) {
                heatmap = new google.maps.visualization.HeatmapLayer({
                    data: data.map(item => ({
                        location: item.location,
                        weight: item.weight
                    })),
                    map: map
                });

                heatmap.set('radius', 50);
                heatmap.set('opacity', 0.7);
                heatmap.set('dissipating', true);
                heatmap.set('maxIntensity', 10);

                // Update gradient to reflect severity levels
                heatmap.set('gradient', [
                    'rgba(0, 255, 0, 0)',
                    'rgba(0, 255, 0, 1)',
                    'rgba(255, 255, 0, 1)',
                    'rgba(255, 165, 0, 1)',
                    'rgba(255, 0, 0, 1)'
                ]);
            }

            function geocodeLocation(location) {
                return new Promise((resolve, reject) => {
                    var geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ address: location }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            var coords = {
                                lat: results[0].geometry.location.lat(),
                                lng: results[0].geometry.location.lng()
                            };
                            resolve(coords);
                        } else {
                            console.error(`Geocoding error for location "${location}": ${status}`);
                            resolve(null);
                        }
                    });
                });
            }

            function getWeightFromSeverity(severity) {
                switch (severity) {
                    case 'Critical':
                        return 3;
                    case 'Mild':
                        return 2;
                    case 'Low':
                        return 1;
                    default:
                        return 1;
                }
            }

            window.onload = initMap;

        </script>
    </body>